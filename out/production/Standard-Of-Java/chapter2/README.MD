# Chapter 02. 변수

## 1. Variable(변수)

중요한 프로그래밍 능력 중의 하나가 바로 '값(data)를 잘 다루는 것'이다. 값을 저장하는 공간인 변수를 잘 이해하고 활용하는 것은 그 능력을 얻기 위한 첫걸음이다.

### 1.1 변수란?

수학에서 `변수`를 `변하는 수`라고 정의하지만 프로그래밍언어에서 변수는 `값을 저장할 수 있는 메모리상의 공간`을 의미한다. 이 공간에 저장된 값은 변경될 수 있기 때문에 `변수`라는 수학용어의 정의와 상통하는 면이 있어서 이렇게 이름이 붙여졌다.

하나의 변수에 단 하나의 값만 저장할 수 있으므로, 새로운 값을 저장하면 기존의 값은 사라진다.


### 1.2 변수의 선언과 초기화

변수를 사용하려면 먼저 변수를 선언해야하는데, 변수의 선언방법은 다음과 같다.

```java
int age;
```

`변수타입`은 변수에 저장될 값이 어떤 타입인지를 지정하는 것이다. 저장하고자하는 값의 종류에 맞게 변수의 타입을 선택해서 적어주면 된다. C언어는 정수형, 실수형, 문자형 등 다양한 타입을 제공한다.

`변수이름`은 말 그대로 변수에 붙인 이름이다. 변수는 `값을 저장할 수 있는 메모리 공간`이므로 변수의 이름은 메모리 공간에 이름을 붙여주는 것이다. 그래야 그 이름을 이용해서 저장공간(변수)에 값을 저장하고, 저장된 값을 읽어오기도 할 수 있는 것이다. 당연한 얘기지만 같은 이름의 변수가 여러 개 존재해서는 안된다. 서로 구별될 수 있어야하기 때문이다.

변수를 선언하면, 메모리의 빈 공간에 `변수타입`에 알맞은 크기의 저장공간이 확보되고, 앞으로 이 저장공간은 `변수이름`을 통해 사용할 수 있게 된다.

#### 변수의 초기화

변수를 선언한 이후부터는 변수를 사용할 수 있으나, 그 전에 반드시 변수를 `초기화(initialization)`해야 한다. 메모리는 여러 프로그램이 공유하는 자원이므로 전에 다른 프로그램에 의해 저장된 `알수 없는 값(쓰레기값, garbage value)`이 남아있을 수 있기 때문이다.

변수에 값을 저장할 때는 대입 연산자(`=`)를 이용한다.

변수의 종류에 따라 변수의 초기화를 생략할 수 있는 경우도 있지만, 변수는 사용되기 전에 적절한 값으로 초기화 하는 것이 좋다.

### 1.3 변수의 명명규칙

> 1. 대소문자가 구분되며 길이에 제한이 없다.
>       
>   - Ture와 true는 서로 다른 것으로 간주된다.
>   
> 2. 예약어를 사용해서는 안 된다.
>   
>   - true는 예약어라서 사용할 수 없지만, True는 가능하다.
> 
> 3. 숫자로 시작해서는 안 된다.
> 
>   - top10은 허용되지만, 10top은 허용되지 않는다.
> 
> 4. 특수문자는 '_'와 '$'만을 허용한다.
> 
>   - $harp는 허용되지만, S#arp은 허용되지 않는다.


예약어는 키워드(keyword) 또는 `reserved word`라고 하는데, 프로그래밍언어의 구문에 사용되는 단어를 뜻한다. 그래서 예약어는 클래스나 변수, 메서드의 이름으로 사용할 수 없다.

이외에도 필수적인 것은 아니지만 자바 프로그래머에게 권장하는 규칙들은 다음과 같다.

> 1. 클래스 이름의 첫 글자는 항상 대문자로 한다.
> 2. 여러 단어로 이루어진 이름은 단어의 첫글자를 대문자로 한다.
> 3. 상수의 이름은 모두 대문자로 한다. 여러 단어로 이루어진 경우 '_'로 구분한다.

위의 규칙들은 반드시 지켜야 하는 것은 아니지만, 코드를 보다 이해하기 쉽게 하기 위한 자바 개발자들 사이의 암묵적인 약속이다. 이 규칙을 따르지 않는다고 해서 문제가 되는 것은 아니지만 가능하면 지키도록 노력하자. 만일 특별한 방식으로 식별자를 작성해야 한다면 미리 규칙(coding convention)을 정해놓고 프로그램 전체에 일관되게 적용하는 것이 필요하다.


## 2. 변수의 타입

주로 사용하는 값(data)의 종류(type)은 크게 '문자와 숫자'로 나눌 수 있으며, 숫자는 다시 '정수와 실수'로 나눌 수 있다.

이러한 값의 종류에 따라 값이 저장될 공간의 크기와 저장형식을 정의한 것이 자료형이다. 자료형에는 문자형(char), 정수형(byte, short, int, long), 실수형(float, double) 등이 있으며, 변수를 선언할 때는 저장하려는 값의 특성을 고려하여 가장 알맞은 자료형을 변수의 타입으로 선택하면 된다.

#### 기본형과 참조형

자료형은 크게 `기본형`과 `참조형` 두 가지로 나눌 수 있는데, `기본형` 변수는 실제 값(data)을 저장하는 반면, `참조형` 변수는 어떤 값이 저장되어 있는 `주소(memory address)`를 값으로 갖는다. 자바는 C언어와 달리 참조형 변수 간의 연산을 할 수 없으므로 실제 연산에 사용되는 것은 모두 기본형 변수이다.

> [참고] 메모리에는 1byte 단위로 일련번호가 붙어있는데, 이 번호를 메모리 주소 또는 간단히 주소라고 한다. 객체의 주소는 객체가 저장된 메모리 주소를 뜻한다.

> [기본형]
> - 논리형(boolean), 문자형(char), 정수형(byte, short, int, long), 실수형(float, double)
> - 계산을 위한 실제 값을 저장
> 
> [참조형]
> - 객체의 주소를 저장


참조형 변수(또는 참조변수)를 선언할 때는 변수의 타입으로 클래스의 이름을 사용하므로 클래스의 이름이 참조변수의 타입이 된다. 그래서 새로운 클래스를 작성한다는 것은 새로운 참조형을 추가흔 셈이다.

다음은 참조변수를 선언하는 방법이다. 기본형 변수와 같이 변수이름 앞에 타입을 적어주는데 참조변수의 타입은 클래스의 이름이다.

```java
클래스이름 변수이름;   // 변수의 타입이 기본형이 아닌 것들은 모두 참조변수
```

다음은 Date 클래스 타입의 참조변수 today를 선언하는 것이다. 참조변수는 null 또는 객체의 주소를 값으로 갖으며 참조변수의 초기화는 다음과 같이 한다.

객체를 생성하는 연산자 new의 결과는 생성된 객체의 주소이다. 이 주소가 대입연산자 '='에 의해서 참조변수 today에 저장되는 것이다. 이제 참조변수 today를 통해서 생성된 객체를 사용할 수 있게 된다.

> 참조형 변수는 null 또는 객체의 주소를 값으로 갖는다. null은 어떤 객체의 주소도 저장되어 있지 않음을 뜻한다. 단, JVM이 32 bit가 아니라 64bit라면 참조형 변수의 크기는 8byte가 된다.


### 2.1 기본형(Primitive Type)

기본형에는 모두 8개의 타입(자료형)이 있으며, 크게 논리형, 문자형, 정수형, 실수형으로 구분된다.

문자형인 char는 문자를 내부적으로 정수(유니코드)로 저장하기 때문에 정수형과 별반 다르지 않으며, 정수형 또는 실수형과 연산도 가능하다. 반면에 boolean은 다른 기본형과의 연산이 불가능하다. 즉, boolean을 제외한 나머지 7개의 기본형은 서로 연산과 변환이 가능하다.

정수형은 가장 많이 사용되므로 타입을 4가지나 제공한다. 각 타입마다 저장할 수 있는 값의 범위가 다르므로 저장할 값의 범위에 맞는 타입을 선택하면 되지만, 일반저긍로 int를 많이 사용한다. 왜냐하면, int는 CPU가 가장 효율적으로 처리할 수 있는 타입이기 때문이다. 효율적인 실행보다 메모리 절약하려면, byte나 short을 선택하자.


### 2.2 상수와 리터럴(constant & literal)

`상수`는 변수와 마찬가지로 `값을 저장할 수 있는 공간`이지만, 변수와 달리 한 번 값을 저장하면 다른 값으로 변경할 수 없다. 상수를 선언하는 방법은 변수와 동일하며, 단지 변수의 타입 앞에 키워드 `final`을 붙여주기만 하면 된다.

```java
final int MAX_SPEED = 10;
```

그리고 상수는 반드시 선언과 동시에 초기화해야 하며, 그 후 부터는 상수의 값을 변경하는 것이 허용되지 않는다.

#### 리터럴(Literal)

리터럴은 상수의 다른 이름이다.

- 변수(Variable) : 하나의 값을 저장하기 위한 공간
- 상수(Constant) : 값을 한번만 저장할 수 있는 공간
- 리터럴(Literal) : 그 자체로 값을 의미하는 것

#### 상수가 필요한 이유

상수는 리터럴에 `의미있는 이름`을 붙여서 코드의 이해와 수정을 쉽게 만든다.

#### 리터럴의 타입과 접미사

변수에 타입이 있는 것처럼 리터럴에는 타입이 있다. 변수의 타입은 저장될 `값의 타입(리털럴의 타입)`에 의해 결정되므로, 만일 리터럴에 타입이 없다면 변수의 타입도 필요없을 것이다.

정수형과 실수형에는 여러 타입이 존재하므로, 리터럴에 접미사를 붙여서 타입을 구분한다. 정수형의 경우, long타입의 리터럴에 접미사 'l'또는 'L'을 붙이고, 접미사가 없으면 int 타입의 리터럴이다. byte와 short타입의 리터럴은 별도로 존재하지 않으며 byte와 short 타입의 변수에 값을 저장할 때는 int 타입의 리터럴을 사용한다.

실수형 리터럴에서는 float타입의 리렅럴에 접미사 'f'또는 'F'를 붙이고, double 타입의 리터럴에는 접미사 'd' 또는 'D'를 붙이고 double형에 경우 접미사 'd'는 생략이 가능하다.

#### 타입의 불일치

리터럴의 타입은 저장될 변수의 타입과 일치하는 것이 보통이지만, 타입이 달라도 저장범위가 넓은 타입에 좁은 타입의 값을 저장하는 것은 허용된다.

그러나 리터럴의 값이 변수의 타입의 범위를 넘어서거나, 리터럴의 타입이 변수의 타입보다 저장범위가 넓으면 컴파일 에러가 발생한다.

#### 문자 리터럴과 문자열 리터럴

'A'와 같이 작은 따옴표로 문자 하나를 감싼 것은 '문자 리터럴'이라고 한다. 두 문자 이상은 큰 따옴표로 감싸야 하며 '문자열 리터럴'이라고 한다.

### 2.3 형식화된 출력 - printf()

화면에 출력할 때 `println()`을 써왔는데, `println()`은 사용하기엔 편하지만 변수의 값을 그대로 출력하므로, 값을 변환하지 않고는 다른 형식으로 출력할 수 없다. 같은 값이라도 다른 형식으로 출력하고 싶을 때가 있다. 예를 들면, 소수점 둘쨰자리까지만 출력한다던가, 정수를 16진수나 8진수로 출력한다던가. 이럴 때 `printf()`를 사용하면 된다.

`println()`는 `지시자(specifier)`를 통해 변수의 값을 여러 가지 형식으로 변환하여 출력하는 기능을 가지고 있다. `지시자`는 값을 어떻게 출력할 것인지를 지정해주는 역할을 한다.

정수형 변수에 저장된 값을 10진 정수로 출력할 떄는 지사자 '%d'를 사용하며, 변수의 값을 지정된 형식으로 지시자대신 넣는다. 예를 들어 int타입의 변수 age의 값이 14일 때, `printf()`는 `%d` 대신 14를 넣어서 출력한다.

```java
System.out.printf("age:%d", age);
```

`println()`과 달리 printf()는 출력 후 줄바꿈을 하지 않는다. 줄바꿈을 하려면 지시자 '%n'을 따로 넣어줘야 한다.

> '%n'대신 '\n'을 사용해도 되지만, OS마다 줄바꿈 문자가 다를 수 있기 때문에 '%n'을 사용하는 것이 더 안전하다.

`printf()`의 지시자 중에서 자주 사용되는 것만 뽑아보면 다음과 같다.

- %b: 불리언(boolean) 형식으로 출력
- %d: 10진(decimal) 정수의 형식으로 출력
- %o: 8진(octal) 정수의 형식으로 출력
- %x, %X: 16(hexa-decimal) 정수의 형식으로 출력
- %f: 부동 소수점(floating-point)의 형식으로 출력
- %e, %E: 지수(exponent) 표현식의 형식으로 출력
- %c: 문자(character)로 출력
- %s: 문자열(string)로 출력


### 2.4 화면에서 입력받기

자바에서 화면으로 부터 입력받는 방법은 여러 가지가 있으며, 점점 간단하고 편리한 방향으로 발전해 왔다. 최신 방법은 JDK 1.6부터 추가된 Console클래스를 이용하는 것인데, 이 클래스는 이클립스와 같은 IDE에서 잘 동작하지 않으므로, 이와 유사한 Scanner 클래스를 이용해서 화면으로부터 입력받는 방법이 있다.

## 3. 진법

### 3.1 10진법과 2진법

우리는 일상생활에서 주로 사용하는 것은 10진법이다. 사람이 10개의 손가락을 가지고 있기 때문이 아닐까. 1946년에 개발된 컴퓨터인 에니탁(ENIAC)은 사람에게 익숙한 10진법을 사용하도록 설계되었으나 전기회로로는 전압이 불안정해서 전압을 10단계로 나누어 처리하는 데 한계가 있었다. 그래서 1950년에 개발된 에드박(EDVAC)은 단계 전가가 흐르면 1, 흐르지 않으면 0만으로 동작하도록 설계되었고 매우 성공적이었다. 손가락의 개수가 10개인 사람에게 10진법이 적당하듯, 컴퓨터와 같은 전기회로에는 2진법이 적합한 것이다.

그 이후부터 지금까지 대부분의 컴퓨터는 2진 체계로 설계되었기 때문에, 2진법을 알지 못하면 컴퓨터의 동작원리나 데이터 처리방식을 완전히 이해할 수 없다.

이처럼 2진법은 0과 1로만 데이터를 표현하기 떄문에 10진법에 비해 많은 자리수를 필요로 한다. 10진수 2와 같이 작은 숫자도 2진수로 표현하려면 2자리가 필요하다. 2진수 한 자리로는 1보다 큰 값을 표현할 수 없기 때문이다.

### 3.2 비트(bit)와 바이트(byte)

한 자리의 2진수를 `비트(bit, binary digit)`라고 하며, 1 비트는 컴퓨터가 값을 저장할 수 있는 최소단위이다. 그러나 1비트는 너무 작은 단위이기 때문에 1 비트 8개를 묶어서 `바이트(byte)`라는 단위로 정의해서 데이터의 기본 단위로 사용한다.

이 외에도 `워드(word)`라는 단위가 있는데, `워드(word)`는 `CPU가 한 번에 처리할 수 있지만, 사실 워드의 크기`는 CPU의 성능에 따라 달라진다. 예를 들어 32 비트 CPU에서 1워드는 32비트(4바이트)이고, 64비트 CPU에서는 64 비트(8바이트)이다.

> nibble: 4bit, 16진수 1자리를 저장할 수 있는 단위


### 3.3 8진법과 16진법

2진법은 0과 1, 두 개의 기호만으로 값을 표현하기 때문에, 2진법으로 값을 표현하면 자리수가 상당히 길어진다는 단점이 있다. 이러한 단점을 보완하기 위해 2진법 대신 8진법이나 16진법을 사용한다.

`8진수는 진수 3자리를, 16진수는 2진수 4자리를 각각 한자리로 표현할 수 있기 때문에 자리수가 짧아져서 알아보기 쉽고 서로 간의 변환방법 또한 매우 간단하다.`

### 3.4 정수의 진법 변환

#### 10진수를 n진수로 변환

10진수를 다른 진수로 변환하려면, 해당 진수로 나누고 나머지 값을 옆에 적는 것을 더 이상 나눌 수 없을 때까지 반복한 다음 마지막 몫과 나머지를 아래부터 위로 순서대로 적으면 된다.

#### n진수를 10진수로 변환

어떤 진법의 수라도 10진수로 변환하는 방법은 똑같다. 각 자리의 수에 해당 다누이의 값을 곱해서 모두 더하면 된다.

### 3.5 실수의 진법 변환

#### 10진 소수점수를 2진 소수점수로 변환하는 방법

10진 정수를 2진 소수점수로 변환하는 방법은 10진 정수를 2진 정수로 변환하는 것과 정반대로 10진 소수점수에 2를 계속 곱한다.


### 3.6 음수의 2진 표현 - 2의 보수법

n비트의 2진수로 표현할 수 있는 값의 개수는 모두 2^n 개이므로, 4비트의 2진수로는 모두 2^4(=16)개의 값을 표현할 수 있다.

'왼쪽의 첫 번째 비트(MSB)'가 0이면 양수, 1이면 음수이므로 첫 번쨰 비트만으로 값의 부호를 알 수 있다.


#### 2의 보수법

어떤 수의 'n의 보수'는 더했을 때 n이 되는 수를 말한다. 7의 '10의 보수'는 3이고, 3의 '10의 보수'는 7이다. 3과 7은 '10의 보수의 관계'에 있다고 한다. '2의 보수 관계' 역시 더해서 2가 되는 두 수의 관계를 말하며 10진수 2는 2진수로 '10'이다. 진수로 '
10'은 자리올림이 발생하고 0이 되는 수를 뜻한다. 그래서 '2의 보수 관계'에 있는 두 2진수를 더하면 '(자리올림이 발생하고) 0이 된다.'

#### 음수를 2진수로 표현하기

10진 음의 정수를 2진수로 변환하려면, 먼저 10진수 음의 절대값을 2진수로 변환한다. 그 다음에 2진수의 '2의 보수'를 구하면 된다. 

```java
-5(10) -> 5(10) -> 0101(2) -> 1011(2)
```

#### 2의 보수 구하기

서로 '2의 보수'의 관계에 있는 두 수를 더하면 '0(자리올림 발생)'이 된다. 예를 들어 2진수 '0101'의 '2의 보수'를 구하려면, '0101'에 어떤 수를 더하면 0이 되는지 알아내야 한다.

> 0101 + ????(2의 보수) = 1 0000

아래와 같이 뺄셈으로 '2의 보수'를 간단히 구할 수 있지만 자리수가 많아지면 뺼셈도 쉽지 않다.

> 1 0000 - 0101 = 1011(2의 보수)

다행이 뺄셈보다 '2의 보수'를 더 간단히 구하는 방법이 있다. '1의 보수'를 구한 다음 1을 더한다. 그러면 2의 보수를 구할 수 있다.

> 2의 보수 = 1의 보수 + 1

#### 왜 '1의 보수 + 1'은 '2의 보수'인가?

어떤 2진수가 있을 때, 이 2진수의 1의 보수를 더하면 모든 자리가 1이 된다.

> 0101 + 1010(1의 보수) = 1111

위의 식에서 양변에 1을 더하면 우변은 0이 된다. 올림(carry)이 발생하지만 4비트를 넘는 값이라 저장할 공간이 없어서 버려진다.

> 0101 + 1010 + 1 = 1111 + 1
> 0101 + (1010 + 1) = 1 0000

위의 식에서 알 수 있듯이 어떤 수에 '1의 보수 + 1'을 더하면 0이 되므로 '1의 보수 + 1'은 '2의 보수'와 같다는 것이 증명된다.

## 4. 기본형(Primitive type)

### 4.1 논리형(boolean)

논리형에는 'boolean' 한가지 밖에 없다. boolean형 변수에는 true와 false 중 하나를 저장할 수 있으며 기본값(default)은 false이다.

boolean형 변수는 대답(yes/no), 스위치(on/off) 등의 논리구현에 주로 사용된다. 그리고 boolean형은 true와 false, 두 가지의 값만을 표현하면 되므로 1bit만으로도 충분하지만, 가바에서는 데이터를 다루는 최소단위가 byte이기 때문에, boolean의 크기가 1byte이다.

자바에서는 대소문자가 구별되기 때문에 TRUE와 true는 다른 것으로 간주된다는 것에 주의해야합니다.

### 4.2 문자형 - char

문자형 역시 'char' 한 가지 자료형밖에 없다. 문자를 저장하기 위한 변수를 선언할 때 사용되며, char타입의 변수는 단 하나의 문자만을 저장할 수 있다. 아래의 문장은 char타입의 변수 ch를 선언하고 문자 'A'로 초기화한다.

```java
char ch = 'A';
```

문자가 아닌 '문자의 유니코드(정수)'가 저장된다. 컴퓨터는 숫자밖에 모르기 때문에 모든 데이터를 숫자로 변환하여 저장하는 것이다. 문자 'A'의 유니코드는 65이므로, 변수 ch에는 65가 저장된다.

그래서 문자 리터럴 대신 문자의 유니코드를 직접 저장할 수 있다. 문자 'A'의 유니코드는 10진수로 65이므로, 아래의 두 문장은 동일한 결과를 얻는다.

```java
char ch = 'A';
char ch = 65;
```

어떤 타입(type, 형)을 다른 타입으로 변환하는 것을 형변환(캐스팅, casting)이라고 한다.

#### 특수 문자 다루기

영문자 이외에 tab이나 backspace 등의 특수문자를 저장하려면, 아래와 같이 조금 특별한 방법을 사용한다.

```java
char tab = '\t';
```

'\t'는 실제로는 두 문자로 이루어져 있지만 한 문자(탭, tab)을 의미한다.

![특수문자를 표현하는 방법](https://github.com/bangseongmin/Standard-Of-Java/assets/22147400/1448fdc0-c8d5-4015-927b-c0092fe2ef0d)

#### char타입의 표현방식

char타입의 크기는 2byte(16bit)이므로, 16자리의 2진수로 표현할 수 있는 정수의 개수인 65536개(2^16)의 코드를 사용할 수 있으며, char형 변수는 이 범위 내의 코드 중 하나를 저장할 수 있다.

char타입은 문자를 저장할 변수를 선언하기 위한 것이지만, 실제로 char타입의 변수에는 문자가 아닌 '문자의 유니코드(정수)'가 저장되고 표현형식 역시 정수형과 동일하다. 다만, 정수형과 달리 음수를 나타낼 필요가 없으므로 표현할 수 있는 값의 범위가 다르다.

2byte로는 모두 2^16(65536)개의 값을 표현할 수 있는데, char타입에 저장되는 값인 유니코드는 모두 양수이므로, '0~65535'의 범위를 가지며, 정수형인 'short'은 절반을 음수표현에 사용하므로 '-32768~32767'을 범위로 갖는다.

다음과 같이 변수에 ch와 s에 'A'와 65를 저장하면, 둘 다 2진수로 똑같은 값이 저장된다. 컴퓨터는 모든 값을 0과 1로 바꾸어 저장하기 때문이다.

```java
char ch = 'A';
short s = 65;
```

두 변수의 값을 출력해보면 결과가 다르다. println()은 변수의 타입이 정수형이면 변수에 저장된 값을 10진수로 해석하여 출력하고, 문자형이면 저장된 숫자에 해당하는 유니코드 문자를 출력하기 때문이다.

이처럼 값은 어떻게 해석하냐느에 따라 결과가 달라지므로 값만으로는 값을 해석할 수 없다. 값의 타입까지 알아야 올바르게 해석할 수 있는 것이다.

#### 인코딩과 디코딩(Encoding & Decoding)

컴퓨터가 숫자밖에 모르기 때문에 문자가 숫자로 변환되어 저장된다는 것은 알겠는데, 그러면 도대체 어떤 기준에 의한 것일까? 바로 유니코드이다.

문자를 코드로 변환하는 것을 '문자 인코딩', 반대로 코드를 문자로 변환하는 것을 '문자 디코딩'이라고 하며, 문자를 저장할 때는 인코딩을 해서 숫자로 변환해서 저장하고, 저장된 문자를 읽어올 때는 디코딩을 해서 숫자를 원래의 문자로 되돌려8야 한다.

### 4.3 정수형 - Byte, Short, Int, Long

정수형에는 모두 4개의 자료형이 있으며, 각 자료형이 저장할 수 있는 값의 범위가 서로 다르다. 크기순으로 나열하면 다음과 같다. 단위는 byte이다.

- byte (1byte)
- short (2byte)
- int (4byte)
- long (8byte)

이 중에서는 기본 자룡형(default datat type)은 int이다.

#### 정수형의 표현 형식과 범위

어떤 진법의 리터럴을 변수에 저장해도 실제로는 2진수로 바뀌어 자장된다. 이 2진수가 저장되는 형식은 크게 정수형과 실수형이 있으며, 정수형은 다음과 같은 형식으로 저장된다.

![정수형의 표현형식](https://github.com/bangseongmin/Standard-Of-Java/assets/22147400/c08c5214-ab2f-4636-9035-ccc640721866)

모든 정수형은 부호있는 정수이므로 왼쪽의 첫 번째 비트를 '부호 비트(sign bit)'로 사용하고, 나머지는 값을 표현하는데 사용한다. 그래서 n 비트로 표현할 수 있는 값의 개수인 2^n개에서, 절반인 '0'으로 시작하는 2^n-1개의 값을 양수(0도 포함)의 표현에 사용하고, 나머지 절반인 '1'로 시작하는 2^n-1개의 값은 음수의 표현에 사용한다.

그래서 정수형은 타입의 크기만 알면, 최대값과 최소값을 쉽게 계산해낼 수 있다.

> n비트로 표현할 수 있는 정수의 개수: 2^n개(= 2^n-1개 + 2^n+1개)
> n비트로 표현할 수 있는 부호있는 정수의 범위: -2^n-1 ~ 2^n-1 - 1

위의 범위의 최대값에서 1을 빼는 이유는 범위에 0이 포함되기 때문이다.

#### 정수형의 선택기준

변수에 저장하려는 정수값의 범위에 따라 4개의 정수형 중에서 하나를 선택하면 되곘지만, byte나 short보다 int를 사용하도록 하자. byte와 short이 int보다 크기가 작아서 메모리를 조금 더 절약할 수는 있지만, 저장할 수 있는 값의 범위가 작은 편이라서 연산 시에 버무이를 넘어서 잘못된 결과를 얻기가 쉽다.

JVM의 피연산자 스택(operand stack)이 피연산자를 4 byte단위로 저장하기 때문에 크기가 4 byte보다 작은 자료형(byte, short)의 값을 계산할 때는 byte로 변환하여 연산이 수행된다. 그래서 오히려 int를 사용하는 것이 더 효율적이다.

결론적으로 정수형 변수를 선언할 때는 int 타입으로 하고, int의 범위를 넘어서는 수를 다뤄야 할 때는 long을 사용하면 된다. 그리고 byte나 short은 성능보다 저장공간을 절약하는 것이 더 중요할 때 사용하자.

#### 정수형의 오버플로우

연산과정에서 해당 타입이 푤현할 수 있는 값의 범위를 넘어서는 것을 `오버플로우(overflow)`라고 한다. 오버플로우가 발생했다고 해서 에러가 발생하는 것은 아니다. 만일 예상했던 결과를 얻지 못할 뿐이다.

#### 부호있는 정수의 오버플로우

부호없는 정수는 2진수로 '0000'이 될때 오버플로우가 발생하고, 부호있는 정수는 부호비트가 0에서 1이 될때 오버플로우가 발생한다.

short와 char의 크기는 모두 16bit이므로 표현할 수 있는 값의 개수는 65536으로 같지만, short는 절반을 음수로 표현하는데 사용하고, char은 0과 양수을 표현하는데 사용한다.


### 4.4 실수형(float, double)

#### 실수형의 범위와 정밀도

실수형은 실수를 저장하기 위한 타입으로 float와 double, 두 가지 있으며 각 타입의 변수에 저장할 수 있는 값의 범위는 아래와 같다.

![실수형의 범위와 정밀도](https://github.com/bangseongmin/Standard-Of-Java/assets/22147400/b974eb3a-3c18-4bf9-ad6b-f03cc76eef90)

'양의 범위'만 적은 것으로, 이 범위에 '-'부호를 붙이면 '음의 범위'가 된다.

실수형은 소수점수도 표현해야 하므로 '얼마나 큰 값을 표현할 수 있는가'뿐만 아니라 '얼마나 0에 가깝게 표현할 수 있는가'도 중요하다.

> Q. 실수형도 정수형처럼 저장할 수 있는 범위를 넘게 되면 오버플로우가 발생하나요?
> A. 앞서 정수형에서 변수의 값이 표현범위를 벗어나는 것을 '오버플로우(overflow)'라고 하였는데, 실수형에서도 변수의 값이 표현범위의 최대값을 벗어나면 '오버플로우'가 발생합니다. 정수형과 달리 실수형에서는 오버플로우가 발생하면 변수의 값은 '무한대(infinity)'가 됩니다.
> 그리고 정수형에는 없는 '언더플로우(underflow)'가 있는데, '언더플로우'는 실후영으로 표현할 수 없는 아주 작은 값, 즉 양의 최소값보다 작은 값이 되는 경우를 말합니다. 이 때 변수의 값은 0이 됩니다.

4byte의 정수로는 '약 ±2x10^9'의 값밖에 표현할 수 없는데, 어떻게 같은 4byte로 '±3.4x10^38'과 같이 큰 값을 표현할 수 있는 것일까? 그 이유는 바로 값을 저장하는 형식이 다르기 때문이다.

위 그림은 int타입과 float타입의 표현형식을 비교한 것인데, int 타입은 '부호와 값', 두 부분으로 이루어져있지만, float타입과 같은 실수형은 '부호(S), 지수(E), 가수(M)', 세 부분으로 이루어져 있다. 즉, '2의 제곱을 곱한 형태(±M x 2^E)'로 저장하기 때문에 이렇게 큰 범위의 값을 저장하는 것이 가능한 것이다.

그러나 정수형과 달리 실수형은 오차가 발생하는 수 있다는 단점이 있다. 그래서 실수형에는 표현할 수 있는 값의 범위뿐만 아니라 '정밀도(precision)'도 중요한 요소이다.

#### 실수형의 저장형식

실수형은 정수형과 표현형식이 달라서, 실수형은 값을 부동소수점수(floating-point)의 형태로 저장한다. 부동소수점수는 실수를 '±Mx2^E'와 같은 형태로 표현하는 것을 말하며, 부동소주머수는 부호(Sign), 지수(Exponent), 가수(Mantissa), 모두 세 부분으로 이루어져 있다.

- ![실수 표현형식의 구성요소](https://github.com/SWYG-GreenSumer/GreenSumer_Back/assets/22147400/4b31bfb4-5d5d-440d-9c2f-1f8ddd397012)

1. 부호(Sign bit)

    'S'는 부호비트(Sign Bit)를 의미하며 1bit이다. 이 값이 0이면 양수를, 1이면 음수를 의미한다. 정수형과 달리 '2의 보수법'을 사용하지 않기 떄문에 야으이 실수를 음의 실수로 바꾸려면 그저 부호비트만 0에서 1로 변경하면 된다.

2. 지수(Exponent)

    'E'는 지수를 저장하는 부분으로 float의 경우, 8bit의 저장공간을 갖는다. 지수는 '부호 있는 정수'이고 8bit로는 모두 2^8(=256)개의 값을 저장할 수 있으므로 '-127~128'의 값이 저장된다. 이 중에서 -127과 128은 '숫자 아님(NaN, Not a Number)'이나 '양의 무한대(POSITIVE_INFINITY)', '음의 무한대(NEGATIVE_INFINITY)'와 같이 븍별한 값의 표현을 위해 예약되어 있으므로 실제로 사용가능한 지수의 범위는 '-126 ~ 127'이다. 그래서 지수의 최대값이 127이므로 float타입으로 표현할 수 있는 최대값은 2^127이고, 10진수로는 약 10^38이다. 그러나 float의 최소값은 가수의 마지막 자리가 2^-23이므로 지수의 최소값보다 2^-23배나 더 작은 값, 약 10^-45이다.

3. 가수(Mantissa)
    
    'M'은 실제 값인 가수를 저장하는 부분으로 float의 경우, 2진수 23자리를 저장할 수 있다. 2진수 23자리로는 약 7자리의 10진수를 저장할 수 있는데 이것이 바로 float의 정밀도가 된다. double은 가수를 저장할 수 있는 공간이 52자리로 float보다 약 2배이므로 double이 float보다 약 2배의 정밀도를 갖는 것이다.

#### 부동 소수점의 오차

실수 중에는 '파이'와 같은 무한소수가 존재하므로, 정수와 달리 실수를 저장할 떄는 오차가 발생할 수 있다. 게다가 10진수가 아닌 2진수로 저장하기 떄문에 2진수로는 유한소수이더라도, 2진수로 변환하면 무한소수가 되는 경우도 있다. 2진수로는 10진 소수를 정확히 표현하기 어렵기 때문이다.

2진수로 변환된 실수를 저장할 떄는 '1.xxx X 2^n'의 형태로 변환하는데, 이 과정을 정규화라고 한다.

정규화된 2진 실수는 항상 '1.'으로 시작하기 때문에, '1.'을 제외한 23자리의 2진수가 가수(mantissa)로 저장되고 그 이후는 잘려나간다. 지수는 기저법으로 저장되기 때문에, 지수인 3에 기저인 127을 더한 130이 2진수로 변환되어 저장된다.

> [참고] 기저법은 '2의 보수법'처럼 부호있는 정수를 저장하는 방법이다. 저장할 떄 특정값(기저)을 더했다가 읽어올 떄는 다시 뺀다.

## 5. 형 변환

### 5.1 형변환(캐스팅, Casting)이란?

모든 변수와 리터럴에는 타입이 있다. 프로그램을 작성하다 보면 같은 타입뿐만 아니라 서로 다른 타입간의 연산을 수행해야하는 경우가 있다. 이럴 떄는 연산을 수행하기 전에 타입을 일치시켜야 하는데, 변수나 리터럴의 타입을 다른 타입으로 변환하는 것을 '형변환(Casting)'이라 한다.

> 형변환이란, 변수 또는 상수의 타입을 다른 타입으로 변환하는 것

### 5.2 형변환 방법

> (타입) 피연산자

기본형(primitive type)에는 boolean을 제외한 나머지 타입들은 서로 형변환이 가능하다. 그리고 기본형과 참조형간의 형변환은 불가능하다.

### 5.3 정수형간의 형변환

큰 타입에서 작은 타입으로 변환, '값의 손실'이 발생할 수 있다. 반대로 작은 타입에서 큰 타입으로의 변환하는 경우는 저장공간의 부족으로 잘려나가는 일이 없으므로 값 손실이 발생하지 않는다.

### 5.4 실수형 간의 형변환

실수형에서도 정수형처럼 작은 타입에서 큰 타입으로 변환하는 경우, 빈 공간을 0으로 채운다.

### 5.5 정수형과 실수형 간의 형변환

#### 정수형을 실수형으로 변환

정수는 소수점이하의 값이 없으므로 간단하다. 정수를 2진수로 변환한 다음 정규화를 거쳐 실수의 저장형식으로 저장된다.

실수형은 정수형보다 훨씬 큰 저장범위를 갖기 때문에, 정수형을 실수형으로 변환하는 것은 무리가 없다. 정수를 2진수로 변환한 다음에 정규화해서 실수의 저장형식에 맞게 저장할 뿐이다. 한 가지 주의할 점은 실수형의 정밀도의 제한으로 인한 오차가 발생할 수 있다.


#### 실수형을 정수형으로 변환

실수형을 정수형으로 변환하면, 실수형의 소수점이하 값은 버려진다. 정수형의 표현 형식으로 소수점 이하의 값은 표현할 수 없기 때문이다. 예를 들어 float 타입의 상수 9.1234567f를 int 타입으로 형변환 하면 9가 된다.

``

